package client;

import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.net.DatagramPacket;
import java.net.DatagramSocket;
import java.net.SocketException;
import java.util.Hashtable;
import java.util.Timer;
import java.util.TimerTask;
import java.util.logging.Logger;


//UDP client sends a message to the server and gets a reply

public class receptionHandler{

	private DatagramSocket connectionSocket = null;
	private paquetUDP connectionPacket;
	private int serverPort = 0;
	//private DatagramPacket packetReceive;
	//private static final Logger logger = Logger.getAnonymousLogger();
	private Hashtable<Integer, paquetUDP> fenetre = new Hashtable<Integer,paquetUDP>();

	public receptionHandler(int port){ 
		serverPort = port;
	}

	protected paquetUDP buildPacket(int seq, int ack, byte[] data) {

		paquetUDP packet = new paquetUDP(connectionPacket.getType(),connectionPacket.getDestination(),connectionPacket.getDestinationPort());
		packet.setData(data);
		packet.setSeq(seq);
		packet.setSeq(ack);
		//logger.debug(packet.toString());
		return packet;
	}

	protected void sendPacket(paquetUDP udpPacket) {
		try {

			//logger.debug(udpPacket.toString());
			byte[] packetData = Marshallizer.marshallize(udpPacket);
			DatagramPacket datagram = new DatagramPacket(packetData,
					packetData.length, 
					udpPacket.getDestination(),
					udpPacket.getDestinationPort());
			connectionSocket.send(datagram); // Ã©mission non-bloquante
		} catch (SocketException e) {
			System.out.println("Socket: " + e.getMessage());
		} catch (IOException e) {
			System.out.println("IO: " + e.getMessage());
		}
	}

	public void start() throws IOException
	{
		connectionSocket = new DatagramSocket();

		//on set le pckt a recevoir
		byte[] buffer = new byte[1500];
		DatagramPacket datagram = new DatagramPacket(buffer, buffer.length);

		//reception bloquante du paquet seq=1
		connectionSocket.receive(datagram);


		Timer timer = new Timer(); //Timer pour les timeouts
		//ENVOI DU SEQ=1 ACK=1
		paquetUDP confirmConnectionPacket = buildPacket(1,1,new byte[1024]);
		timer.scheduleAtFixedRate(new TimerTask() 
		{
			public void run() 
			{
				sendPacket(confirmConnectionPacket);
			}
		}, 0, 1000);
		timer.cancel();

		//PREMIERE RECEPTION DE DATA
		int seqAttendu = 1;
		int ackRetour=1;
		
		FileOutputStream fileOut = new FileOutputStream("hd.jpg");
		do
		{
			connectionSocket.receive(datagram);
			
			//CREATION PAQUET A RECEVOIR ET ACK A RENVOYER
			paquetUDP UDPReceive = (paquetUDP) Marshallizer.unmarshall(datagram);
			paquetUDP receveACK = buildPacket(seqAttendu, ackRetour,new byte[1024] );
			
			//ON AJOUTE LE PAQUET RECU AU H_TABLE
			if(fenetre.containsKey(UDPReceive.getSeq())==false)fenetre.put(UDPReceive.getSeq(), UDPReceive);
			
			//SI SEQ RECUE =SEQ ATTENDUE
			if (UDPReceive.getSeq()==seqAttendu)
			{
				
				//ON ECRIT LES DONNES RECUES DANS LE FICHIER
				fileOut.write(UDPReceive.getData());
				//ACK CONFIRME RECEPTION DU PAQUET ATTENDU
				ackRetour = seqAttendu;
				seqAttendu +=UDPReceive.getData().length;
			}
			sendPacket(receveACK);
			if(UDPReceive.getFin() == 1)closeConnection(UDPReceive.getSeq(),UDPReceive.getAck()) ;

		}while(true);
		
	}
	
	public void closeConnection(int seqNum, int ackNum) throws IOException
	{
		Timer timer = new Timer(); //Timer pour les timeouts
		//ENVOI DU ACK DE FIN
		paquetUDP endPqt = buildPacket(seqNum, ackNum, new byte[1024]);
		timer.scheduleAtFixedRate(new TimerTask() 
		{
			public void run() 
			{
				sendPacket(endPqt);
			}
		}, 0, 1000);
		timer.cancel();
		
		connectionSocket.close();
	}

}
